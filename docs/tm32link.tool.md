# Specification - TM32 Linker Tool

Below is the specification for a linker tool used for processing and linking
object files generated by the TM32 Assembler Tool into executable binaries which
can be run on hardware powered by the TM32 CPU architecture, such as the TM32
Core.

## 1. Overview

The TM32 Linker Tool (`tm32link`) is a command-line utility that takes
multiple TM32 object files (`.tmo`, `.o`, `.obj`, etc.) as input, processes
them and links them, performing symbol resolution, relocation, and section
merging to produce a final executable binary file (`.tm32`, `.tm`, etc.) that
can be loaded and run on TM32-based hardware.

### 1.1 References

This document only details the linker tool itself, but will reference other
related specifications as needed:

- For more information on the TM32 assembly language, refer to the
  [TM32 Assembly Language Specification](tm32asm.language.md).
- For more information on the TM32 assembler tool, refer to the
  [TM32 Assembler Tool Specification](tm32asm.tool.md).
- For more information on the TM32 CPU architecture and its instruction set,
  refer to the [TM32 CPU Specification](tm32cpu.specification.md) and the
  [TM32 Instruction Set Reference](tm32cpu.instructions.md).

## 2. Usage

The TM32 Linker Tool is invoked from the command line with the following
syntax:

```bash
$ tm32link [options] <input_files> -o <output_file>
```

### 2.1 Command-Line Options

The following options are available for the `tm32link` command:

- `-o <output_file>, --output <output_file>`: Specify the name of the output
    executable file. This option is required. Common extensions include `.tm32`,
    `.tm`, and `.bin`.
- `-L <library_dir>, --library-dir <library_dir>`: Add a directory to the list
    of directories to search for library files. This option can be specified
    multiple times to add multiple directories.
- `-l <library_name>, --library <library_name>`: Link against a library. The
    linker will search for files named `lib<library_name>.tmo` or 
    `<library_name>.tmo` in the library search paths.
- `-s <section>=<address>, --section <section>=<address>`: Set the base address
    for a specific section. For example, `-s .text=0x3000` sets the code section
    to start at address `0x3000`. Can be used multiple times for different
    sections.
- `--entry <symbol>`: Specify the entry point symbol for the executable. If not
    provided, the linker will use a default entry point or the first instruction
    in the `.text` section.
- `--map <map_file>`: Generate a memory map file showing the layout of sections
    and symbols in the final executable. Useful for debugging and analysis.
- `--no-stdlib`: Do not automatically link against the standard TM32 runtime
    library. By default, the linker includes basic runtime support.
    - **Note**: At this time, there is no standard library for the TM32
      architecture, so this option does nothing.
- `--strip`: Remove symbol table and debugging information from the output
    executable to reduce file size.
- `--verbose, -V`: Enable verbose output, providing detailed information about
    the linking process, including file processing and symbol resolution.
- `--warn-common`: Warn when common symbols are encountered. Common symbols
    can indicate potential issues with variable declarations across multiple
    object files.
- `--fatal-warnings`: Treat all warnings as fatal errors. The linker will exit
    with a non-zero status code if any warnings are encountered.
- `--gc-sections`: Enable garbage collection of unused sections. The linker
    will remove sections that are not referenced by any code, reducing the
    final executable size.
- `--check-sections`: Verify that all sections fit within their assigned memory
    regions according to the TM32 memory map. Report errors if sections exceed
    available memory.
- `--stack-size <size>`: Reserve the specified amount of memory for the stack.
    The linker will ensure this space is available in the stack region
    (`0xFFFE0000` to `0xFFFEFFFF`).
- `--version, -v`: Display version information and exit.
- `--help, -h`: Display usage information and a summary of available options.

### 2.2 Input and Output Files

- **Input Files**: The linker accepts multiple TM32 object files as input. These
    files are typically generated by the TM32 Assembler Tool and can have any
    extension, though `.tmo`, `.o`, and `.obj` are common conventions.
- **Output File**: The output executable file is specified with the `-o` option.
    The output format is a raw binary file suitable for loading onto TM32-based
    hardware. Common extensions for the output file include `.tm32`, `.tm`, and
    `.bin`.

## 3. Functionality

The TM32 Linker Tool performs several key operations to transform multiple
object files into a single executable binary. The linking process occurs in
several distinct phases, each handling specific aspects of the final executable
generation.

### 3.1 Object File Loading

The linker begins by loading and parsing all input object files specified on
the command line. During this phase:

- **File Format Validation**: Each object file is validated to ensure it
    conforms to the TM32 object file format produced by the assembler.
- **Section Discovery**: The linker identifies all sections (`.text`, `.rodata`,
    `.data`, `.bss`, `.metadata`, `.int`) present in the input files.
- **Symbol Table Extraction**: Symbol tables from each object file are loaded
    and merged into a global symbol table for later resolution.
- **Relocation Information**: Relocation entries are collected to identify
    addresses that need to be adjusted during the linking process.

### 3.2 Symbol Resolution

Symbol resolution is the process of matching symbol references with their
definitions across all input object files:

- **Global Symbol Table**: The linker maintains a comprehensive symbol table
    containing all exported symbols from input object files.
- **Undefined Symbol Detection**: The linker identifies symbols that are
    referenced but not defined in any input file.
- **Library Linking**: When undefined symbols are found, the linker searches
    specified library directories for additional object files that define
    these symbols.
- **Duplicate Symbol Checking**: The linker detects and reports duplicate
    symbol definitions, which typically indicate programming errors.
- **Weak Symbol Support**: The linker handles weak symbols that can be
    overridden by strong symbol definitions.

### 3.3 Section Merging and Layout

The linker combines sections of the same type from multiple object files and
determines their final memory layout:

- **Section Combining**: All `.text` sections are merged into a single code
    section, `.rodata` sections are combined for read-only data, etc.
- **Address Assignment**: Based on command-line options and the TM32 memory
    map, the linker assigns final addresses to each section.
- **Alignment Requirements**: The linker ensures that sections are properly
    aligned according to TM32 architecture requirements.
- **Memory Map Validation**: The linker verifies that all sections fit within
    their designated memory regions and do not overlap.

### 3.4 Relocation Processing

Relocation adjusts addresses in the machine code to reflect the final memory
layout of the executable:

- **Address Calculation**: The linker calculates the final addresses of all
    symbols based on their section assignments and offsets.
- **Code Patching**: Machine code instructions that reference symbols are
    updated with the correct addresses.
- **Data Reference Updates**: Data sections containing address references are
    updated to point to the correct memory locations.
- **Relocation Type Handling**: The linker processes different types of
    relocations (absolute, relative, etc.) according to TM32 addressing modes.

### 3.5 Optimization

The linker can perform various optimizations to improve the final executable:

- **Dead Code Elimination**: When `--gc-sections` is enabled, the linker
    removes unused functions and data to reduce executable size.
- **Section Ordering**: Sections can be reordered to optimize memory usage
    and execution performance.
- **Symbol Table Optimization**: Unused symbols can be removed when debugging
    information is not required.

## 4. Executable File Format

The output of the TM32 Linker Tool is a binary executable file that can be
loaded and run on TM32-based hardware. The executable format is designed to
map directly to the TM32 memory layout for efficient loading and execution.

### 4.1 Binary Layout

When loaded into memory, the executable takes on the same layout as the
read-only memory region of the TM32 memory map:

| Start Address | End Address   | Size       | Description                                  |
|---------------|---------------|------------|----------------------------------------------|
| 0x00000000    | 0x00000FFF    | 4 KB       | Program Metadata (`.metadata`)               |
| 0x00001000    | 0x00002FFF    | 8 KB       | Interrupt Vectors (`.int xx`)                |
| 0x00003000    | 0x7FFFFFFF    | Up to 2 GB | Code and Read-Only Data (`.text`, `.rodata`) |

### 4.2 Program Metadata Section

The metadata section (0x00000000 - 0x00000FFF) contains important information
describing the executable. Exactly what is included depends on the hardware
platform powered by the TM32 CPU architecture, but typically includes the
following:

- **A Magic Number**: A fixed byte sequence at the start of the file to identify
    it as a TM32 executable intended to run on a specific platform. For example,
    the magic string `TM32CORE` (0x54 0x4D 0x33 0x32 0x43 0x4F 0x52 0x45) is the
    magic number for executables targeting the TM32 Core platform.
- **Version Information**: The version of the TM32 architecture or platform
    that the executable is built for. Usually, this will be a single byte
    indicating the major version number, followed by a minor version byte,
    followed optionally by a word containing a patch version number.
- **Memory Requests**: Platform-specific fields indicating the amount of ROM
    and RAM space requested by the program. For instance, programs targeting
    the TM32 Core may specify the amount of ROM, Work RAM and Save RAM they
    require, in bytes.
- **Program Title, Author and Description**: Optional human-readable strings
    providing metadata about the program, such as its name, author, and a brief
    description. These strings are typically null-terminated and may be of
    variable length.

#### A Note on Entry Points

For programs targeting the TM32 CPU architecture, the entry point address is
always the start of the Program Code section (`0x00003000`). The metadata section
should not contain an explicit entry point address, as this is fixed by the
architecture.

### 4.3 Interrupt Vector Section

The interrupt vector section (0x00001000 - 0x00002FFF) contains the interrupt
service routine addresses:

- **Vector Table**: 32 interrupt vectors, each allocated 256 bytes of space.
- **Default Handlers**: The linker can provide default interrupt handlers for
    vectors not explicitly defined in the source code.
- **Vector Validation**: The linker ensures all interrupt vectors point to
    valid code addresses within the executable.
- **Return Instructions**: Each interrupt vector shall contain a return
    instruction (`RET NC` or `RETI`) to ensure proper interrupt handling.

### 4.4 Code and Data Section

The main program section (0x00003000 - 0x7FFFFFFF) contains the executable code
and read-only data:

- **Code Segment**: Contains all assembled machine instructions from `.text`
    sections.
- **Read-Only Data**: Constants, strings, and other immutable data from
    `.rodata` sections.
- **Symbol Information**: When not stripped, symbol tables and debugging
    information are included.

### 4.5 Loading Characteristics

The executable format is designed for efficient loading on TM32 hardware:

- **Direct Mapping**: The file can be loaded directly into memory at address
    0x00000000 without additional processing.
- **Position Independence**: While the executable is linked for specific
    addresses, the format supports position-independent execution when needed.
- **Minimal Headers**: The format avoids complex headers to reduce loading
    overhead on resource-constrained systems.

For more details on the TM32 memory map, refer to the
[TM32 CPU Specification](tm32cpu.specification.md).

## 5. Data Structures

The TM32 Linker Tool uses several internal data structures to manage the
linking process. Understanding these structures helps explain the linker's
behavior and can be useful for debugging complex linking issues.

### 5.1 Object File Representation

Each loaded object file is represented by an internal structure containing:

```c
typedef struct {
    char *filename;              // Source file name
    uint8_t *file_data;          // Raw file contents
    size_t file_size;            // Size of file in bytes
    
    section_t *sections;         // Array of sections
    size_t section_count;        // Number of sections
    
    symbol_t *symbols;           // Local symbol table
    size_t symbol_count;         // Number of symbols
    
    relocation_t *relocations;   // Relocation entries
    size_t relocation_count;     // Number of relocations
} object_file_t;
```

### 5.2 Section Management

Sections are managed using the following structure:

```c
typedef struct {
    char name[MAX_SECTION_NAME]; // Section name (.text, .data, etc.)
    section_type_t type;         // Section type enumeration
    uint32_t base_address;       // Base address in memory
    uint32_t size;               // Size in bytes
    uint32_t alignment;          // Required alignment
    uint8_t *data;               // Section contents
    uint32_t flags;              // Section flags (readable, writable, etc.)
} section_t;
```

Section types are defined as:

```c
typedef enum {
    SECTION_METADATA,    // Program metadata
    SECTION_INTERRUPT,   // Interrupt vectors
    SECTION_TEXT,        // Executable code
    SECTION_RODATA,      // Read-only data
    SECTION_DATA,        // Initialized data
    SECTION_BSS          // Uninitialized data
} section_type_t;
```

### 5.3 Symbol Table

The global symbol table maintains information about all symbols in the program:

```c
typedef struct {
    char name[MAX_SYMBOL_NAME];  // Symbol name
    symbol_type_t type;          // Symbol type
    symbol_scope_t scope;        // Symbol scope (local, global, weak)
    uint32_t address;            // Final address
    uint32_t size;               // Symbol size
    section_t *section;          // Containing section
    object_file_t *source_file;  // Source object file
} symbol_t;
```

Symbol types include:

```c
typedef enum {
    SYMBOL_FUNCTION,     // Code function
    SYMBOL_VARIABLE,     // Data variable
    SYMBOL_CONSTANT,     // Read-only constant
    SYMBOL_LABEL,        // Address label
    SYMBOL_SECTION      // Section symbol
} symbol_type_t;
```

### 5.4 Relocation Entries

Relocations specify how addresses should be adjusted during linking:

```c
typedef struct {
    uint32_t offset;             // Offset within section
    relocation_type_t type;      // Type of relocation
    symbol_t *symbol;            // Target symbol
    int32_t addend;              // Additional offset
    section_t *section;          // Section containing relocation
} relocation_t;
```

Relocation types supported by the TM32 architecture:

```c
typedef enum {
    RELOC_ABSOLUTE_32,   // 32-bit absolute address
    RELOC_ABSOLUTE_16,   // 16-bit absolute address
    RELOC_ABSOLUTE_8,    // 8-bit absolute address
    RELOC_RELATIVE_16,   // 16-bit relative address
    RELOC_RELATIVE_8,    // 8-bit relative address
    RELOC_HIGH_16,       // Upper 16 bits of address
    RELOC_LOW_16         // Lower 16 bits of address
} relocation_type_t;
```

### 5.5 Memory Map

The linker maintains a memory map to track address assignments:

```c
typedef struct {
    uint32_t start_address;      // Starting address
    uint32_t end_address;        // Ending address
    memory_type_t type;          // Memory type
    section_t *assigned_section; // Assigned section (if any)
    bool is_available;           // Available for allocation
} memory_region_t;
```

Memory types correspond to TM32 memory regions:

```c
typedef enum {
    MEMORY_METADATA,     // Program metadata region
    MEMORY_INTERRUPT,    // Interrupt vector region
    MEMORY_CODE,         // Code and read-only data region
    MEMORY_RAM,          // General RAM region
    MEMORY_STACK,        // Stack region
    MEMORY_IO            // I/O register region
} memory_type_t;
```

### 5.6 Linker Context

The main linker context structure coordinates the entire linking process:

```c
typedef struct {
    object_file_t *input_files;     // Array of input object files
    size_t input_file_count;        // Number of input files
    
    symbol_t *global_symbols;       // Global symbol table
    size_t global_symbol_count;     // Number of global symbols
    
    section_t *output_sections;     // Final output sections
    size_t output_section_count;    // Number of output sections
    
    memory_region_t *memory_map;    // Memory layout
    size_t memory_region_count;     // Number of memory regions
    
    char *output_filename;          // Output file name
    linker_options_t options;       // Command-line options
    
    error_list_t errors;            // Collected errors
    warning_list_t warnings;        // Collected warnings
} linker_context_t;
```

## 6. Conclusion

The TM32 Linker Tool is a critical component of the TM32 development toolchain,
responsible for transforming individual object files into executable binaries
that can run on TM32-based hardware. Through its comprehensive linking process,
the tool handles symbol resolution, section merging, relocation processing,
and memory layout to produce optimized executable files.

### 6.1 Key Features

The linker provides several important capabilities:

- **Flexible Memory Management**: Support for custom section addressing and
    memory layout configuration through command-line options.
- **Comprehensive Symbol Resolution**: Robust handling of symbol references
    across multiple object files with library linking support.
- **Optimization Features**: Dead code elimination and section garbage
    collection to minimize executable size.
- **Debugging Support**: Generation of memory maps and preservation of symbol
    information for development and debugging purposes.
- **Error Detection**: Extensive validation of memory layout, symbol
    definitions, and section compatibility.

### 6.2 Integration with TM32 Toolchain

The linker works seamlessly with other TM32 tools:

- **Assembler Integration**: Processes object files generated by the TM32
    Assembler Tool, maintaining compatibility with all assembly language
    features.
- **Architecture Alignment**: Designed specifically for the TM32 CPU
    architecture, respecting memory map constraints and instruction set
    requirements.
- **Development Workflow**: Supports iterative development through verbose
    output, warning controls, and debugging information generation.

### 6.3 Performance Considerations

The linker is designed for efficiency in both development and runtime contexts:

- **Fast Linking**: Optimized algorithms for symbol resolution and section
    merging minimize link times during development.
- **Memory Efficiency**: Careful memory management during the linking process
    supports large projects without excessive resource consumption.
- **Output Optimization**: Generated executables are optimized for loading
    speed and runtime performance on TM32 hardware.

### 6.4 Future Enhancements

While the current linker implementation provides comprehensive functionality,
future versions may include:

- **Incremental Linking**: Support for faster rebuilds by linking only changed
    object files.
- **Link-Time Optimization**: Advanced optimization passes that operate across
    object file boundaries.
- **Enhanced Library Support**: More sophisticated library management and
    dependency resolution.
- **Additional Output Formats**: Support for debugging formats and alternative
    executable layouts.

### 6.5 Best Practices

For optimal results when using the TM32 Linker Tool:

- **Use Memory Maps**: Generate memory map files (`--map`) for complex projects
    to understand final executable layout.
- **Enable Section Checking**: Use `--check-sections` to validate memory
    layout constraints during development.
- **Leverage Garbage Collection**: Enable `--gc-sections` for release builds
    to minimize executable size.
- **Monitor Warnings**: Pay attention to linker warnings, as they often
    indicate potential runtime issues.
- **Organize Sections**: Use explicit section addressing (`-s`) for projects
    with specific memory layout requirements.

The TM32 Linker Tool represents a mature and capable linking solution for the
TM32 architecture, providing the foundation for reliable and efficient program
development targeting TM32-based systems.
